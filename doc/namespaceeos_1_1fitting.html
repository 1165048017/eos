<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>eos: eos::fitting Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">eos
   &#160;<span id="projectnumber">0.6.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceeos.html">eos</a></li><li class="navelem"><a class="el" href="namespaceeos_1_1fitting.html">fitting</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">eos::fitting Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Pose and shape fitting of a 3D Morphable Model.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structeos_1_1fitting_1_1_frustum.html">Frustum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class representing a camera viewing frustum. At the moment used as orthographic camera only.  <a href="structeos_1_1fitting_1_1_frustum.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structeos_1_1fitting_1_1_orthographic_rendering_parameters.html">OrthographicRenderingParameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a set of estimated model parameters (rotation, translation) and camera parameters (viewing frustum).  <a href="structeos_1_1fitting_1_1_orthographic_rendering_parameters.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:afce5f7297094056a04ad26785c94bbd8"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1fitting.html#afce5f7297094056a04ad26785c94bbd8">estimate_affine_camera</a> (std::vector&lt; cv::Vec2f &gt; image_points, std::vector&lt; cv::Vec4f &gt; model_points)</td></tr>
<tr class="separator:afce5f7297094056a04ad26785c94bbd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e99a34e412f0bb5b2c6568dd37ae413"><td class="memItemLeft" align="right" valign="top">cv::Vec2f&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1fitting.html#a3e99a34e412f0bb5b2c6568dd37ae413">project_affine</a> (cv::Vec4f vertex, cv::Mat affine_camera_matrix, int screen_width, int screen_height)</td></tr>
<tr class="separator:a3e99a34e412f0bb5b2c6568dd37ae413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae68794185075b5b67fddae9d359cf208"><td class="memItemLeft" align="right" valign="top">std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1fitting.html#ae68794185075b5b67fddae9d359cf208">fit_shape_to_landmarks_linear</a> (<a class="el" href="classeos_1_1morphablemodel_1_1_morphable_model.html">morphablemodel::MorphableModel</a> morphable_model, cv::Mat affine_camera_matrix, std::vector&lt; cv::Vec2f &gt; landmarks, std::vector&lt; int &gt; vertex_ids, float lambda=3.0f, boost::optional&lt; int &gt; num_coefficients_to_fit=boost::optional&lt; int &gt;(), boost::optional&lt; float &gt; detector_standard_deviation=boost::optional&lt; float &gt;(), boost::optional&lt; float &gt; model_standard_deviation=boost::optional&lt; float &gt;())</td></tr>
<tr class="separator:ae68794185075b5b67fddae9d359cf208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f7464a6c6dee7b3885638014ec009a"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1fitting.html#a93f7464a6c6dee7b3885638014ec009a">to_mat</a> (const glm::mat4x4 &amp;glm_matrix)</td></tr>
<tr class="memdesc:a93f7464a6c6dee7b3885638014ec009a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a glm::mat4x4 to a cv::Mat.  <a href="#a93f7464a6c6dee7b3885638014ec009a">More...</a><br /></td></tr>
<tr class="separator:a93f7464a6c6dee7b3885638014ec009a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a503a126cfe1bbd6a7c8b7a786a8e73b8"><td class="memItemLeft" align="right" valign="top">glm::mat4x4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1fitting.html#a503a126cfe1bbd6a7c8b7a786a8e73b8">get_4x4_modelview_matrix</a> (<a class="el" href="structeos_1_1fitting_1_1_orthographic_rendering_parameters.html">fitting::OrthographicRenderingParameters</a> params)</td></tr>
<tr class="memdesc:a503a126cfe1bbd6a7c8b7a786a8e73b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a 4x4 model-view matrix from given fitting parameters.  <a href="#a503a126cfe1bbd6a7c8b7a786a8e73b8">More...</a><br /></td></tr>
<tr class="separator:a503a126cfe1bbd6a7c8b7a786a8e73b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af600978a071bc5dc0443cfe41ae613bf"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1fitting.html#af600978a071bc5dc0443cfe41ae613bf">get_3x4_affine_camera_matrix</a> (<a class="el" href="structeos_1_1fitting_1_1_orthographic_rendering_parameters.html">fitting::OrthographicRenderingParameters</a> params, int width, int height)</td></tr>
<tr class="memdesc:af600978a071bc5dc0443cfe41ae613bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a 3x4 affine camera matrix from given fitting parameters. The matrix transforms points directly from model-space to screen-space.  <a href="#af600978a071bc5dc0443cfe41ae613bf">More...</a><br /></td></tr>
<tr class="separator:af600978a071bc5dc0443cfe41ae613bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e713b5555396806a9b26817184eacd0"><td class="memItemLeft" align="right" valign="top">glm::vec4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1fitting.html#a4e713b5555396806a9b26817184eacd0">get_opencv_viewport</a> (int width, int height)</td></tr>
<tr class="memdesc:a4e713b5555396806a9b26817184eacd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a glm/OpenGL compatible viewport vector that flips y and has the origin on the top-left, like in OpenCV.  <a href="#a4e713b5555396806a9b26817184eacd0">More...</a><br /></td></tr>
<tr class="separator:a4e713b5555396806a9b26817184eacd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebab65b3f9f46758b1363a347e6de852"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structeos_1_1fitting_1_1_orthographic_rendering_parameters.html">OrthographicRenderingParameters</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceeos_1_1fitting.html#aebab65b3f9f46758b1363a347e6de852">estimate_orthographic_camera</a> (std::vector&lt; cv::Vec2f &gt; image_points, std::vector&lt; cv::Vec4f &gt; model_points, int width, int height)</td></tr>
<tr class="memdesc:aebab65b3f9f46758b1363a347e6de852"><td class="mdescLeft">&#160;</td><td class="mdescRight">This algorithm estimates the rotation angles and translation of the model, as well as the viewing frustum of the camera, given a set of corresponding 2D-3D points.  <a href="#aebab65b3f9f46758b1363a347e6de852">More...</a><br /></td></tr>
<tr class="separator:aebab65b3f9f46758b1363a347e6de852"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Pose and shape fitting of a 3D Morphable Model. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="afce5f7297094056a04ad26785c94bbd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat eos::fitting::estimate_affine_camera </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; cv::Vec2f &gt;&#160;</td>
          <td class="paramname"><em>image_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cv::Vec4f &gt;&#160;</td>
          <td class="paramname"><em>model_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The Gold Standard Algorithm for estimating an affine camera matrix from world to image correspondences. See Algorithm 7.2 in Multiple View Geometry, Hartley &amp; Zisserman, 2nd Edition, 2003.</p>
<p>Requires &gt;= 4 corresponding points.</p>
<p>The estimated camera matrix works together with <a class="el" href="namespaceeos_1_1render.html#a1adc532475d45d16f7b0c0eddf1bc7cb">render::render_affine(Mesh, cv::Mat, int, int, bool)</a> to for example render the model or extract texture from the image.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">image_points</td><td>A list of 2D image points. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model_points</td><td>Corresponding points of a 3D model. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 3x4 affine camera matrix (the third row is [0, 0, 0, 1]). </dd></dl>

</div>
</div>
<a class="anchor" id="aebab65b3f9f46758b1363a347e6de852"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structeos_1_1fitting_1_1_orthographic_rendering_parameters.html">OrthographicRenderingParameters</a> eos::fitting::estimate_orthographic_camera </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; cv::Vec2f &gt;&#160;</td>
          <td class="paramname"><em>image_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cv::Vec4f &gt;&#160;</td>
          <td class="paramname"><em>model_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This algorithm estimates the rotation angles and translation of the model, as well as the viewing frustum of the camera, given a set of corresponding 2D-3D points. </p>
<p>It assumes an orthographic camera and estimates 6 parameters, [r_x, r_y, r_z, t_x, t_y, frustum_scale], where the first five describe how to transform the model, and the last one describes the cameras viewing frustum (see CameraParameters). This 2D-3D correspondence problem is solved using Eigen's LevenbergMarquardt algorithm.</p>
<p>The method is slightly inspired by "Computer Vision: Models Learning and Inference", Simon J.D. Prince, 2012, but different in a lot of respects.</p>
<p>Eigen's LM implementation requires at least 6 data points, so we require &gt;= 6 corresponding points.</p>
<p>Notes/improvements: The algorithm works reliable as it is, however, it could be improved with the following:</p><ul>
<li>A better initial guess (see e.g. Prince)</li>
<li>Using the analytic derivatives instead of Eigen::NumericalDiff - they're easy to calculate.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">image_points</td><td>A list of 2D image points. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model_points</td><td>Corresponding points of a 3D model. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>Width of the image (or viewport). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>Height of the image (or viewport). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The estimated model and camera parameters. </dd></dl>

</div>
</div>
<a class="anchor" id="ae68794185075b5b67fddae9d359cf208"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;float&gt; eos::fitting::fit_shape_to_landmarks_linear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeos_1_1morphablemodel_1_1_morphable_model.html">morphablemodel::MorphableModel</a>&#160;</td>
          <td class="paramname"><em>morphable_model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat&#160;</td>
          <td class="paramname"><em>affine_camera_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cv::Vec2f &gt;&#160;</td>
          <td class="paramname"><em>landmarks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>vertex_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>lambda</em> = <code>3.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::optional&lt; int &gt;&#160;</td>
          <td class="paramname"><em>num_coefficients_to_fit</em> = <code>boost::optional&lt;int&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::optional&lt; float &gt;&#160;</td>
          <td class="paramname"><em>detector_standard_deviation</em> = <code>boost::optional&lt;float&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::optional&lt; float &gt;&#160;</td>
          <td class="paramname"><em>model_standard_deviation</em> = <code>boost::optional&lt;float&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fits the shape of a Morphable Model to given 2D landmarks (i.e. estimates the maximum likelihood solution of the shape coefficients) as proposed in [1]. It's a linear, closed-form solution fitting of the shape, with regularisation (prior towards the mean).</p>
<p>[1] O. Aldrian &amp; W. Smith, Inverse Rendering of Faces with a 3D Morphable Model, PAMI 2013.</p>
<p>Note: Using less than the maximum number of coefficients to fit is not thoroughly tested yet and may contain an error. Note: Returns coefficients following standard normal distribution (i.e. all have similar magnitude). Why? Because we fit using the normalised basis? Note: The standard deviations given should be a vector, i.e. different for each landmark. This is not implemented yet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">morphable_model</td><td>The Morphable Model whose shape (coefficients) are estimated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">affine_camera_matrix</td><td>A 3x4 affine camera matrix from model to screen-space (should probably be of type CV_32FC1 as all our calculations are done with float). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">landmarks</td><td>2D landmarks from an image, given in clip-coordinates. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vertex_ids</td><td>The vertex ids in the model that correspond to the 2D points. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lambda</td><td>The regularisation parameter (weight of the prior towards the mean). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_coefficients_to_fit</td><td>How many shape-coefficients to fit (all others will stay 0). Not tested thoroughly. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">detector_standard_deviation</td><td>The standard deviation of the 2D landmarks given (e.g. of the detector used), in pixels. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">model_standard_deviation</td><td>The standard deviation of the 3D vertex points in the 3D model, projected to 2D (so the value is in pixels). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The estimated shape-coefficients (alphas). </dd></dl>

</div>
</div>
<a class="anchor" id="af600978a071bc5dc0443cfe41ae613bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat eos::fitting::get_3x4_affine_camera_matrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structeos_1_1fitting_1_1_orthographic_rendering_parameters.html">fitting::OrthographicRenderingParameters</a>&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a 3x4 affine camera matrix from given fitting parameters. The matrix transforms points directly from model-space to screen-space. </p>
<p>This function is mainly used since the linear shape fitting <a class="el" href="namespaceeos_1_1fitting.html#ae68794185075b5b67fddae9d359cf208">fitting::fit_shape_to_landmarks_linear</a> expects one of these 3x4 affine camera matrices, as well as <a class="el" href="namespaceeos_1_1render.html#aafa8c960c3b6eb080da1536cc3634577">render::extract_texture</a>. </p>

</div>
</div>
<a class="anchor" id="a503a126cfe1bbd6a7c8b7a786a8e73b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">glm::mat4x4 eos::fitting::get_4x4_modelview_matrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structeos_1_1fitting_1_1_orthographic_rendering_parameters.html">fitting::OrthographicRenderingParameters</a>&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a 4x4 model-view matrix from given fitting parameters. </p>
<p>Together with the <a class="el" href="structeos_1_1fitting_1_1_frustum.html" title="A class representing a camera viewing frustum. At the moment used as orthographic camera only...">Frustum</a> information, this describes the full orthographic rendering parameters of the OpenGL pipeline. Example:</p>
<div class="fragment"><div class="line">fitting::OrthographicRenderingParameters rendering_params = ...;</div>
<div class="line">glm::mat4x4 view_model = <a class="code" href="namespaceeos_1_1fitting.html#a503a126cfe1bbd6a7c8b7a786a8e73b8">get_4x4_modelview_matrix</a>(rendering_params);</div>
<div class="line">glm::mat4x4 ortho_projection = glm::ortho(rendering_params.frustum.l, rendering_params.frustum.r, rendering_params.frustum.b, rendering_params.frustum.t);</div>
<div class="line">glm::vec4 viewport(0, image.rows, image.cols, -image.rows); <span class="comment">// flips y, origin top-left, like in OpenCV</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// project a point from 3D to 2D:</span></div>
<div class="line">glm::vec3 point_3d = ...; <span class="comment">// from a mesh for example</span></div>
<div class="line">glm::vec3 point_2d = glm::project(point_3d, view_model, ortho_projection, viewport);</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a4e713b5555396806a9b26817184eacd0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">glm::vec4 eos::fitting::get_opencv_viewport </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a glm/OpenGL compatible viewport vector that flips y and has the origin on the top-left, like in OpenCV. </p>
<p>Note: Move to detail namespace / not used at the moment. </p>

</div>
</div>
<a class="anchor" id="a3e99a34e412f0bb5b2c6568dd37ae413"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cv::Vec2f eos::fitting::project_affine </td>
          <td>(</td>
          <td class="paramtype">cv::Vec4f&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat&#160;</td>
          <td class="paramname"><em>affine_camera_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>screen_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>screen_height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Projects a point from world coordinates to screen coordinates. First, an estimated affine camera matrix is used to transform the point to clip space. Second, the point is transformed to screen coordinates using the window transform. The window transform also flips the y-axis (the image origin is top-left, while in clip space top is +1 and bottom is -1).</p>
<p>Note: Assumes the affine camera matrix only projects from world to clip space, because a subsequent window transform is applied. #Todo: This is outdated, now that we estimate the matrix from world to screen space directly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vertex</td><td>A vertex in 3D space. vertex[3] = 1.0f. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">affine_camera_matrix</td><td>A 3x4 affine camera matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">screen_width</td><td>Width of the screen or window used for projection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">screen_height</td><td>Height of the screen or window used for projection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector with x and y coordinates transformed to screen coordinates. </dd></dl>

</div>
</div>
<a class="anchor" id="a93f7464a6c6dee7b3885638014ec009a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat eos::fitting::to_mat </td>
          <td>(</td>
          <td class="paramtype">const glm::mat4x4 &amp;&#160;</td>
          <td class="paramname"><em>glm_matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a glm::mat4x4 to a cv::Mat. </p>
<p>Note: move to render namespace </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
